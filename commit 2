import 'package:flutter/material.dart'; // Importa a biblioteca principal do Flutter para construir a interface do usu√°rio.
import 'dart:async'; // Importa a biblioteca para opera√ß√µes ass√≠ncronas, como timers.

void main() {
  runApp(MyApp()); // Inicia o aplicativo Flutter, executando o widget raiz MyApp.
}

// Define um widget StatefulWidget chamado MyApp. Widgets com estado podem ter seu estado alterado dinamicamente.
class MyApp extends StatefulWidget {
  @override
  _MyAppState createState() => _MyAppState(); // Cria e retorna o estado mut√°vel associado a este widget.
}

// Define a classe _MyAppState, que cont√©m o estado e a l√≥gica do widget MyApp.
class _MyAppState extends State<MyApp> {
  // Uma lista de mapas que representam as perguntas do quiz.
  // Cada mapa cont√©m a pergunta, as op√ß√µes de resposta e a resposta correta.
  final List<Map<String, dynamic>> perguntas = [
    {
      'pergunta': "Quais os fundamentos do v√¥lei corretos descritos abaixo?",
      'opcoes': ['Manchete e toque', 'Observar e defender', 'Passe e defesa'],
      'respostacorreta': 'Passe e defesa',
    },
    {
      'pergunta': "Qual a principal fun√ß√£o de um central dentro de quadra?",
      'opcoes': ['Bloqueio', 'Ataque', 'Saque'],
      'respostacorreta': 'Bloqueio',
    },
    {
      'pergunta': "No rod√≠zio 6x0, qual a principal atividade do jogador que estar√° na 6?",
      'opcoes': ['Pinga', 'Fundo de quadra', 'Pipe'],
      'respostacorreta': 'Fundo de quadra',
    },
    {
      'pergunta': "No sistema de rota√ß√£o 5x1, qual jogador atua nas posi√ß√µes 6 e 4?",
      'opcoes': ['Central', 'Oposto', 'Ponteiro'],
      'respostacorreta': 'Ponteiro',
    },
    {
      'pergunta': "No sistema 5x1, em uma bola quebrada no fundo de quadra, na qual √© imposs√≠vel do levantador chegar, quem assume o levantamento?",
      'opcoes': ['Ponteiro', 'L√≠bero', 'Oposto'],
      'respostacorreta': 'L√≠bero',
    },
    {
      'pergunta': "O que um levantador evita fazer dentro de quadra?",
      'opcoes': ['Passar', 'Defender', 'Bloquear'],
      'respostacorreta': 'Passar',
    },
    {
      'pergunta': "Sobre as regras do V√¥lei de quadra, em que momento √© considerado dois toques?",
      'opcoes': ['Bloqueio', 'Passe', 'Levantamento'],
      'respostacorreta': 'Levantamento',
    },
    {
      'pergunta': "O que √© rally no v√¥lei?",
      'opcoes': [
        'Quando uma partida demora pra acabar',
        'Quando o l√≠bero pega uma bola quase imposs√≠vel',
        'Quando uma partida acaba muito r√°pido',
        'Nenhuma das anteriores'
      ],
      'respostacorreta': 'Nenhuma das anteriores',
    },
    {
      'pergunta': "Qual √© o objetivo principal do voleibol?",
      'opcoes': [
        'Fazer o m√°ximo de pontos poss√≠vel',
        'Impedir que a bola toque no ch√£o do pr√≥prio campo',
        'Fazer a bola tocar no ch√£o dentro do campo advers√°rio',
        'Nenhuma das anteriores'
      ],
      'respostacorreta': 'Fazer a bola tocar no ch√£o dentro do campo advers√°rio',
    },
    {
      'pergunta': "Qual √© a altura oficial da rede para homens e mulheres?",
      'opcoes': ['2,42 e 2,23', '2,40 e 2,24', '2,43 e 2,23', 'Nenhuma das anteriores'],
      'respostacorreta': 'Nenhuma das anteriores',
    },
  ];

  int perguntaAtual = 0; // √çndice da pergunta atualmente exibida.
  int pontos = 0; // Pontua√ß√£o do usu√°rio no quiz.
  String? mensagem; // Mensagem de feedback exibida ap√≥s cada resposta.
  bool quizFinalizado = false; // Indica se todas as perguntas foram respondidas.
  Map<String, Color?> coresBotoes = {}; // Mapa para controlar as cores dos bot√µes de resposta.
  Timer? timer; // Objeto Timer para controlar o tempo de resposta.
  int tempoRestante = 10; // Tempo restante para responder a pergunta atual (em segundos).
  bool isTimerRunning = false; // Indica se o timer est√° atualmente em execu√ß√£o.
  String imagemFeedback = ""; // URL da imagem de feedback (certo/errado) a ser exibida.
  double imagemOpacidade = 0; // Controla a opacidade da imagem de feedback (para anima√ß√£o).

  // Fun√ß√£o ass√≠ncrona para verificar a resposta do usu√°rio.
  void verificarResposta(String respostaEscolhida) async {
    String respostaCorreta = perguntas[perguntaAtual]['respostacorreta'];

    setState(() {
      coresBotoes = {}; // Limpa as cores dos bot√µes antes de exibir o resultado.
      for (var opcao in perguntas[perguntaAtual]['opcoes']) {
        if (opcao == respostaCorreta) {
          coresBotoes[opcao] = Colors.green; // Define a cor do bot√£o da resposta correta para verde.
        } else if (opcao == respostaEscolhida) {
          coresBotoes[opcao] = Colors.red; // Define a cor do bot√£o da resposta escolhida (incorreta) para vermelho.
        }
      }

      bool acertou = respostaEscolhida == respostaCorreta; // Verifica se a resposta escolhida est√° correta.
      bool perguntaImpar = (perguntaAtual + 1) % 2 != 0; // Verifica se o n√∫mero da pergunta atual √© √≠mpar.

      // Atualiza a pontua√ß√£o e a mensagem de feedback com base na corre√ß√£o da resposta.
      if (acertou) {
        pontos++;
        mensagem = '‚úÖ Resposta certa! +1 ponto';
        imagemFeedback = perguntaImpar
            ? 'https://i.imgur.com/DR8iaxB.png' // Imagem para resposta certa em pergunta √≠mpar.
            : 'https://i.imgur.com/zbNG0dd.png'; // Imagem para resposta certa em pergunta par.
      } else {
        mensagem = '‚ùå Resposta errada!';
        imagemFeedback = perguntaImpar
            ? 'https://i.imgur.com/Jjeh3Ne.png' // Imagem para resposta errada em pergunta √≠mpar.
            : 'https://i.imgur.com/neU6P9W.png'; // Imagem para resposta errada em pergunta par.
      }

      imagemOpacidade = 1; // Torna a imagem de feedback vis√≠vel.
    });

    // Aguarda 2 segundos antes de passar para a pr√≥xima pergunta ou finalizar o quiz.
    await Future.delayed(Duration(seconds: 2));

    setState(() {
      mensagem = null; // Limpa a mensagem de feedback.
      coresBotoes.clear(); // Limpa as cores dos bot√µes.
      imagemOpacidade = 0; // Oculta a imagem de feedback.
      if (perguntaAtual < perguntas.length - 1) {
        perguntaAtual++; // Avan√ßa para a pr√≥xima pergunta.
      } else {
        quizFinalizado = true; // Define o quiz como finalizado se todas as perguntas foram respondidas.
      }
    });

    // Se o quiz n√£o estiver finalizado, reinicia o timer para a pr√≥xima pergunta.
    if (!quizFinalizado) {
      resetTimer();
    }
  }

  // Fun√ß√£o para reiniciar o quiz.
  void reiniciarQuiz() {
    setState(() {
      perguntas.shuffle(); // Embaralha a ordem das perguntas.
      for (var pergunta in perguntas) {
        (pergunta['opcoes'] as List).shuffle(); // Embaralha a ordem das op√ß√µes de cada pergunta.
      }
      perguntaAtual = 0; // Reseta o √≠ndice da pergunta atual para 0.
      pontos = 0; // Reseta a pontua√ß√£o para 0.
      quizFinalizado = false; // Reseta o estado de finaliza√ß√£o do quiz para falso.
      mensagem = null; // Limpa qualquer mensagem pendente.
      coresBotoes.clear(); // Limpa as cores dos bot√µes.
      resetTimer(); // Reinicia o timer.
    });
  }

  // Fun√ß√£o para iniciar o timer de resposta.
  void startTimer() {
    setState(() {
      tempoRestante = 20; // Define o tempo inicial para 10 segundos.
      isTimerRunning = true; // Marca o timer como em execu√ß√£o.
    });

    // Cria um timer peri√≥dico que dispara a cada 1 segundo.
    timer = Timer.periodic(Duration(seconds: 1), (Timer t) {
      setState(() {
        if (tempoRestante > 0) {
          tempoRestante--; // Decrementa o tempo restante.
        } else {
          timer?.cancel(); // Cancela o timer quando o tempo chega a zero.
          if (!quizFinalizado) {
            verificarResposta(''); // Verifica a resposta (como se nada tivesse sido escolhido) quando o tempo acaba.
          }
        }
      });
    });
  }

  // Fun√ß√£o para resetar o timer.
  void resetTimer() {
    if (timer?.isActive ?? false) {
      timer?.cancel(); // Cancela o timer atual se estiver ativo.
    }
    startTimer(); // Inicia um novo timer.
  }

  @override
  void initState() {
    super.initState();
    reiniciarQuiz(); // Reinicia o quiz quando o widget √© criado pela primeira vez.
  }

  @override
  void dispose() {
    super.dispose();
    if (timer?.isActive ?? false) {
      timer?.cancel(); // Cancela o timer quando o widget √© removido da √°rvore.
    }
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false, // Remove o banner de "Debug" no canto da tela.
      theme: ThemeData(
        primarySwatch: Colors.orange, // Define a cor prim√°ria do tema para laranja.
        scaffoldBackgroundColor: Colors.green, // Define a cor de fundo do Scaffold para verde.
      ),
      home: Scaffold(
        appBar: AppBar(
          title: Text('üèê V√¥Quiz'), // T√≠tulo da barra superior.
          centerTitle: true, // Centraliza o t√≠tulo na barra superior.
          backgroundColor: Colors.blue[800], // Define a cor de fundo da AppBar para um tom de azul mais escuro.
        ),
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0), // Adiciona um preenchimento ao redor do conte√∫do principal.
            child: quizFinalizado
                ? Column(
                    mainAxisAlignment: MainAxisAlignment.center, // Centraliza os widgets na coluna.
                    children: [
                      Icon(Icons.emoji_events, size: 80, color: Colors.orange), // √çcone de trof√©u para indicar o fim do quiz.
                      SizedBox(height: 20), // Espa√ßamento vertical.
                      Text(
                        'Parab√©ns!\nVoc√™ concluiu o quiz!',
                        textAlign: TextAlign.center,
                        style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                      ),
                      SizedBox(height: 20), // Espa√ßamento vertical.
                      Text('Pontua√ß√£o final: $pontos / ${perguntas.length}',
                          style: TextStyle(fontSize: 18)), // Exibe a pontua√ß√£o final.
                      SizedBox(height: 30), // Espa√ßamento vertical.
                      ElevatedButton(
                        onPressed: reiniciarQuiz, // Chama a fun√ß√£o para reiniciar o quiz ao pressionar o bot√£o.
                        child: Text('üîÅ Recome√ßar'), // Texto do bot√£o de reiniciar.
                        style: ElevatedButton.styleFrom(
                          padding: EdgeInsets.symmetric(horizontal: 30, vertical: 12), // Preenchimento interno do bot√£o.
                          backgroundColor: Colors.orange, // Cor de fundo do bot√£o.
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(20), // Bordas arredondadas do bot√£o.
                          ),
                        ),
                      ),
                    ],
                  )
                : Column(
                    mainAxisAlignment: MainAxisAlignment.center, // Centraliza os widgets na coluna.
                    children: [
                      // Exibe a imagem de feedback se a opacidade for maior que 0 (vis√≠vel).
                      if (imagemOpacidade > 0) ...[
                        AnimatedOpacity(
                          opacity: imagemOpacidade, // Controla a opacidade da imagem.
                          duration: Duration(milliseconds: 400), // Dura√ß√£o da anima√ß√£o de opacidade.
                          child: AnimatedScale(
                            scale: imagemOpacidade, // Controla a escala da imagem (para efeito de "pop").
                            duration: Duration(milliseconds: 400), // Dura√ß√£o da anima√ß√£o de escala.
                            child: Image.network(imagemFeedback, height: 120), // Exibe a imagem da rede.
                          ),
                        ),
                        SizedBox(height: 20), // Espa√ßamento vertical.
                      ],
                      Text(
                        'Pergunta ${perguntaAtual + 1} de ${perguntas.length}', // Exibe o n√∫mero da pergunta atual.
                        style: TextStyle(fontSize: 16, color: Colors.grey[700]), // Estilo do texto.
                      ),
                      SizedBox(height: 20), // Espa√ßamento vertical.
                      AnimatedSwitcher(
                        duration: Duration(milliseconds: 500), // Dura√ß√£o da anima√ß√£o de transi√ß√£o entre perguntas.
                        transitionBuilder: (child, animation) {
                          // Define uma anima√ß√£o de slide e fade para a transi√ß√£o entre as perguntas.
                          return SlideTransition(
                            position: Tween<Offset>(
                              begin: Offset(1.0, 0.0),
                              end: Offset(0.0, 0.0),
                            ).animate(animation),
                            child: FadeTransition(opacity: animation, child: child),
                          );
                        },
                        child: Column(
                          key: ValueKey<int>(perguntaAtual), // Chave √∫nica para for√ßar a reconstru√ß√£o na troca de perguntas.
                          children: [
                            Card(
                              elevation: 5, // Adiciona uma sombra ao redor do card.
                              shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(15)), // Bordas arredondadas do card.
                              child: Padding(
                                padding: const EdgeInsets.all(20.0), // Preenchimento interno do card.
                                child: Text(
                                  perguntas[perguntaAtual]['pergunta'], // Exibe a pergunta atual.
                                  textAlign: TextAlign.center, // Centraliza o texto da pergunta.
                                  style: TextStyle(
                                      fontSize: 20, fontWeight: FontWeight.bold), // Estilo do texto da pergunta.
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                      SizedBox(height: 20), // Espa√ßamento vertical.
                      // Mapeia as op√ß√µes de resposta para criar bot√µes ElevatedButtons.
                      ...perguntas[perguntaAtual]['opcoes'].map<Widget>((opcao) {
                        return Padding(
                          padding: const EdgeInsets.symmetric(vertical: 6.0), // Preenchimento vertical ao redor de cada bot√£o.
                          child: ElevatedButton(
                            onPressed: mensagem == null ? () => verificarResposta(opcao) : null, // Chama verificarResposta ao pressionar se n√£o houver mensagem de feedback.
                            child: Text(opcao, style: TextStyle(fontSize: 16)), // Texto do bot√£o da op√ß√£o.
                            style: ElevatedButton.styleFrom(
                              backgroundColor: coresBotoes[opcao] ?? Colors.orange[300], // Define a cor de fundo do bot√£o com base na resposta.
                              foregroundColor: Colors.black, // Cor do texto do bot√£o.
                              minimumSize: Size(double.infinity, 60), // Define a largura m√°xima e altura m√≠nima do bot√£o.
                              padding: EdgeInsets.symmetric(horizontal: 24, vertical: 16), // Preenchimento interno do bot√£o.
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(12), // Bordas arredondadas do bot√£o.
                              ),
                            ),
                          ),
                        );
                      }).toList(),
                      // Exibe a mensagem de feedback se n√£o for nula.
                      if (mensagem != null) ...[
                        SizedBox(height: 20), // Espa√ßamento vertical.
                        Text(
                          mensagem!, // Exibe a mensagem.
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                            color: mensagem!.contains('‚úÖ') ? Colors.white : Colors.red, // Define a cor da mensagem com base no resultado.
                          ),
                        ),
                        SizedBox(height: 20), // Espa√ßamento vertical.
                      ],
                      // Exibe o tempo restante se o timer estiver em execu√ß√£o.
                      if (isTimerRunning) ...[
                        SizedBox(height: 20), // Espa√ßamento vertical.
                        Text(
                          'Tempo restante: $tempoRestante', // Exibe o tempo restante.
                          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold), // Estilo do texto do tempo.
                        ),
                  
                      ]
                    ],
                  ),
          ),
        ),
      ),
    );
  }
}
